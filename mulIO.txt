Linux sysprog, 2nd ed.

Не прибегая к потокам — в сущности, обслуживая каждый файловый дескриптор отдельно, — одиночный процесс, разумеется, может фиксироваться только на
одном дескрипторе в каждый момент времени. Работать с множественными файловыми дескрипторами удобно, если они всегда готовы к считыванию или записи.
Однако если программа встретит файловый дескриптор, который еще не готов к взаимодействию (допустим, мы выполнили системный вызов read() , а данные
для считывания пока отсутствуют), то процесс блокируется и не сможет заняться работой с какими-либо другими файловыми дескрипторами. Он может блокиро
ваться даже на несколько секунд, из-за чего приложение станет неэффективными будет только раздражать пользователя. Более того, если нужные для файлового
дескриптора данные так и не появятся, то блокировка может длиться вечно. Операции ввода-вывода, связанные с различными файловыми дескрипторами, зачастую
взаимосвязаны (вспомните, например, работу с конвейерами), поэтому один из файловых дескрипторов вполне может оставаться не готовым к работе, пока не
будет обслужен другой. В частности, при работе с сетевыми приложениями, в которых одновременно бывает открыто большое количество сокетов, эта проблема
может стать весьма серьезной.
Допустим, произошла блокировка на файловом дескрипторе, относящемся к межпроцессному взаимодействию. В то же время в режиме ожидания остаются
данные, введенные с клавиатуры (stdin). Пока блокированный файловый дескриптор, отвечающий за межпроцессное взаимодействие, не вернет данные, приложение
так и не узнает, что еще остаются необработанные данные с клавиатуры. Однако что делать, если возврата от блокированной операции так и не произойдет?
Ранее в данной главе мы обсуждали неблокирующий ввод-вывод в качестве возможного решения этой проблемы. Приложения, работающие в режиме неблокиру
ющего ввода-вывода, способны выдавать запросы на ввод-вывод, которые в случае подвисания не блокируют всю работу, а возвращают особое условие ошибки. Это ре
шение неэффективно по двум причинам. Во-первых, процессу приходится постоянно осуществлять операции ввода-вывода в каком-то произвольном порядке, дожидаясь,
пока один из открытых файловых дескрипторов не будет готов выполнить операцию ввода-вывода. Это некачественная конструкция программы. Во-вторых, программа
работала бы эффективнее, если бы могла ненадолго засыпать, высвобождая процессор для решения других задач. Просыпаться программа должна, 
только когда один файловый дескриптор или более будут готовы к обработке ввода-вывода.

--

Мультиплексный ввод-вывод позволяет приложениям параллельно блокировать несколько файловых
дескрипторов и получать уведомления, как только любой из них будет готов к чтению или записи без блокировки, поэтому мультиплексный ввод-вывод оказывает
ся настоящим стержнем приложения, выстраиваемым примерно по следующему
принципу:

1. Мультиплексный ввод-вывод: сообщите мне, когда любой из этих файловых
дескрипторов будет готов к операции ввода-вывода.
2. Ни один не готов? Перехожу в спящий режим до готовности одного или нескольких дескрипторов.
3. Проснулся! Где готовый дескриптор?
4. Обрабатываю без блокировки все файловые дескрипторы, готовые к вводу-выводу.
5. Возвращаюсь к шагу 1


