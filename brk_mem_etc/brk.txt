From M. Kerrisk's book:

...изменение размеров кучи (то есть выделение и высвобождение памяти) сводится лишь
к тому, чтобы всего лишь объяснить ядру, где располагается крайняя точка программы
(program break). Изначально крайняя точка программы находится непосредственно сразу
же за окончанием сегмента неинициализированных данных (то есть там же, где на рис. 6.1
стоит метка &end). После того как эта точка будет сдвинута вверх, программа сможет по-
лучать доступ к любому адресу во вновь выделенной области, но страницы физической
памяти пока выделяться не будут. Ядро автоматически выделит новые физические стра-
ницы при первой же попытке процесса обратиться к адресам этих страниц.

традиционно для манипуляций с крайней точкой программы система UNIX предо-
ставляла два системных вызова, и они оба доступны в Linux: brk() и sbrk(). Хотя в про-
граммах эти системные вызовы напрямую используются довольно редко, в их работе
стоит разобраться, чтобы выяснить порядок выделения памяти.


Системный вызов brk() устанавливает крайнюю точку программы на место, указанное
окончанием сегмента данных — end_data_segment. Поскольку виртуальная память выделяется
постранично, end_data_segment фактически* округляется до границы следующей страницы.
Попытки установить крайнюю точку программы ниже ее первоначального значения,
(то есть ниже метки &end), скорее всего, приведут к неожиданному поведению, например
к сбою сегментирования (сигнал SIGSEGV рассматривается в разделе 20.2) при обращении
к данным в уже не существующих частях сегментов инициализированных или неинициа-
лизированных данных. Точный верхний предел возможной установки крайней точки
программы зависит от нескольких факторов, в числе которых: ограничение ресурсов
процесса для размера сегмента данных (RLIMIT_DATA, рассматриваемое в разделе 36.3),
а также расположение отображений памяти, сегментов совместно используемой памяти
и совместно используемых библиотек.

----
* «фактически» подразумевает, что он не округляется, а ведет себя так, как если бы он был округлен // Это похоже на эвристику: не выравнивать end_data_segment по границе страницы; и убедиться, что размер базовой области виртуального адресного пространства выровнен (округлен) по размеру страницы

#include <stdio.h>
#include <unistd.h>


int
main(int argc, char *argv[])
{
    long int page_size = sysconf(_SC_PAGESIZE);
    printf("My page size: %ld\n", page_size);
    void* c1 = sbrk(0);
    printf("program break address: %p\n", c1);
    printf("sizeof char: %lu\n", sizeof(char));
    c1 = (void*) ((char*) c1 + 1);
    printf("c1: %p\n", c1);
    brk(c1);
    void* c2 = sbrk(0);
    printf("program break address: %p\n", c2); 

}



----
Вызов sbrk() приводит к изменению положения точки программы путем добав -
ления к ней приращения increment. (В Linux функция sbrk() является библиотечной
и реализована в виде надстройки над функцией brk().) Используемый для описания
приращения increment тип intptr_t является целочисленным типом данных. В случае
успеха функция sbrk() возвращает предыдущий адрес крайней точки программы. Ины-
ми словами, если мы подняли крайнюю точку программы, то возвращаемым значением
будет указатель на начало только что выделенного блока памяти.
Вызов sbrk(0) возвращает текущее значение установки крайней точки программы
без ее изменения. Этот вызов может пригодиться, если нужно отследить размер кучи,
возможно, чтобы изучить поведение пакета средств выделения памяти.

----------malloc----------

как мы определили, для выделения небольшого объема памяти он вызывает сдвиг програм брейка.

Вызовем malloc несколько раз понемногу:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/**
 * main - many calls to malloc
 *
 * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 */
int main(void)
{
    void *p;

    write(1, "BEFORE MALLOC #0\n", 17);
    p = malloc(1024);
    write(1, "AFTER MALLOC #0\n", 16);
    printf("%p\n", p);

    write(1, "BEFORE MALLOC #1\n", 17);
    p = malloc(1024);
    write(1, "AFTER MALLOC #1\n", 16);
    printf("%p\n", p);

    write(1, "BEFORE MALLOC #2\n", 17);
    p = malloc(1024);
    write(1, "AFTER MALLOC #2\n", 16);
    printf("%p\n", p);

    write(1, "BEFORE MALLOC #3\n", 17);
    p = malloc(1024);
    write(1, "AFTER MALLOC #3\n", 16);
    printf("%p\n", p);

    getchar();
    return (EXIT_SUCCESS);
}

Посмотрев трассу системных вызовов, мы сделаем вывод, что brk не вызывается каждый раз. 
Это как раз связано с тем, что сдвиг происходит "как бы до конца страницы". А в дальнейшем
использует кусочки из предварительно выделенной памяти.


cat /proc/$(process_id)/maps , [heap]


