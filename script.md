3 семестр информатики -- это курс "Операционные системы", который следовало бы озаглавить "Введение в ОС". Материала много, занятий -- мало.

Курс, в особенности лекционный материал, посвящен основным принципам построения и функционирования операционных систем.
Теоретический материал составлен таким образом, чтобы абстрагироваться от конкретной ОС, хотя на практике, да и местами на лекциях, мы будем рассматривать Unix-подобные ОС на примере Linux.

Мы рассмотрим не всё, и за большим нужно обращаться к литературе:

Литература:

1) Карпов, Коньков, 2-е (3-е) изд. 
2) Э. Таненбаум, Х. Бос "Современные ОС"
3) Керриск "Линукс API: исчерпывающее руководство"
4) Avi Silbershatz, Operating System Concept, 2018.

1-й период эволюции.
==

Программирование в тот период -- переключение логических вентилей, составленных из вакуумно-электронных элементов (ламп). Отладка -- ручной поиск перегоревших ламп, ошибок в схемах и т.д. Все сотрудники, работающие с компьютером -- инженеры-вычислители, разделения труда нет.
Возникновение первых компиляторов (с ассемблера в машинные коды)
Операционных систем не существует.
Основной результат -- становление архитектуры фон Неймана. Данные и код теперь лежат в одной памяти.

2-й период эволюции.
== 
Переход к полупроводниковой электронике. 
Взлёт алгоритмических ЯП. Формируется каста программистов. Это люди, которые заняты исключительно программированием -- созданием, тестированием и отладкой программ.
Многократно переиспользованный код стали сохранять на перво(или магнитные) ленты, и загружать в память машины автоматически. Так появились библиотеки. Программы, требующие одних и тех же библиотек, стали собирать вместе и ставить на исполнение. Так появились пакеты.

3-й период эволюции.
== 
Переход к интегральным схемам -- несколько логических элементов на кристалле. 
I/O выносят в отдельные аппаратные блоки, таким образом процессор занят в основном вычислениями, а не вводом-выводом. Использование спулинга через жесткие диски.

Формируется ряд концепций ОС, которые мы наблюдаем и сейчас:

* По хорошему, программе нужно запретить ходить в чужую память. Следовательно, нужна изоляция памяти.

* Также при переключении между программами нужно сохранять-восстанавливать состояние этих программ -- возникает понятие контекста (память + содержимое регистров + ...)

* Если бы пользовательские программы напрямую занимались вводом-выводом, это бы занимало кучу времени -- вместо выполнения вычислений, программа что-то пишет или читает из устройства, при этом остальные программы ждут. Следовательно, нужно запретить пользовательским программам ...

- Привилегированные команды -- только программа координатор (Ядро ОС), пользовательские команды не имеют права их выполнять напрямую.
Значит, нужно уметь просить координатора следать то или иное действие -- системные вызовы -- точки входа в координатор, обращаясь к которым, пользовательские программы могут выполнить ...

- Непривилегированные команды -- любые программы
* Прерывания...



* Иногда программа состоит из нескольких одновременно работающих программ, нужно передавать данные от 1 к 2. То есть нужны примитивы межпрограммного взаим.

* Если порядок важен, нужны примитивы синхронизации.

ОС == мультипрограммная пакетная система на этом этапе.

+ мультипрограммность -- переосмысление (вытесняющая многозадачность). Квант времени -- переход к системам разделения времени. Переключение происходит не только если программе нужно переключиться, а и по истечении кванта времени.

* возникает идея о том, что в памяти можно хранить только ту часть программы и данных, которая нам нужна сейчас (+ подкачка).
* Создание иллюзии -- виртуальная память. Строится отображение физической памяти во множество адресов, доступных программе при работе. В результате, физической памяти может быть много меньше, чем виртуальной.
* Развитие интерактивных систем, в особенности, систем отладки.
* Появляется понятие файловой системы как способа организации файлов на диске

В то время софт переписывался от поколения системы к системе. И возникла идея объединять машины в семейства. С совместимостью и т.д.

4-й период эволюции.
==

Большие интегральные схемы -- целый процессор на кристалле. Персональные компьютеры. Интерфейс взаимодействия с пользователем.
Происходит резкая деградация ОС для таких компьютеров. Всё переходит на уровень однопрограммных интерактивных систем.
По мере роста объемов вычислений происходит обратно переход. ПК становится мультипользовательскими.

Начинается массовое объединение компьютеров в сети. Появляется понятие сетевых и распределенных ОС -- способ обеспечивающий работу пользователя на компьютере в сети.

5-й период эволюции.
==
Многоядерные процессоры. HPC. Системы на кристаллах. Мобильные системы. Виртуализация.

Основные функции ОС.
==
* Планирование заданий и использование процессора
* Межпрограммная коммуникация
* Управление памятью
* Управление ФС
* Управление вводом-выводом
* Обеспечение безопасности

Эти функции сложились эволюционно-исторически. ОС -это просто разумный способ существования современных вычислительных систем.
Мы будем рассматривать эти функции в рамках нашего курса.


Архитектура ОС.
==
Монолитное ядро:
+ (+)просто и вычислительно эффективно
- (-)при добавлении \ удалении \ изменении -- перекомпилировать всё ядро
- (-)тяжело отлаживать и тестировать

Многоуровневые системы (монолит, разделенный на уровни): -- в настоящее время используются только для отдельных компонент (например, сетевой стек)
+ (+)Упрощает тестирование, отладку
+ (+)Уровень можно заменить
- (-)Медленнее

Микроядерная архитектура:
Микроядро работает в привилегированном режиме. Абстракции типа ФС и т.д. наворачиваются уже над микроядром. Остальные части системы -- в пространстве пользователя. Взаимодействие происходит путем передачи сообщений через микроядро.
+ (+)требует меньше оперативной памяти
+ (+)проектировать проще, чем многоуровневые
- (-)Работает крайне медленно. Узкое место по производительности -- микроядро. 
+ (+)Просто отлаживать

В реальности, нет "чистых" реализаций:
* Линукс -- это монолитное ядро с поддержкой модулей, которые работают в привилегированном режиме в адресном пространстве ядра. То есть это гибридная архитектура.
* Виндовз -- утверждается, что Виндовз НТ -- это микроядро, но они по ходу работы туда ввинтили очень много функциональности, и по факту микроядро таковым быть перестало.

Вообще -- практика - лучший судья, вот поэтому чистых архитектур на практике не существует.

Виртуальные машины.
==
