Linux: 
    В целом, планировщик в Линукс идеологически похож на то, что мы рассмотрели: в самом примитивном случае он вырожден до раунд робин, в котором время виртуализированно в соответствии с приоритетом.
    Но цель "в асимптотике -- выдать всем процессом поровну виртуального времени" соблюдается, так менее (О(1)) или более строго (ЦФС). Способ доставания процесса из очереди нюансен:

    O(1) scheduler — вкратце, политика планировщика была довольно проста: каждый cpu имел 2 очереди: 
    в одной находятся таски, которые в скором времени будут запущены, в другом — спящие таски. 
    когда первая очередь оказывалась пуста, она менялась местами со второй, соответсвенно во второй очереди все спящие процессы 'просыпались', 
    а в первая служила очередью для отработавших и уснувших процессов. 
    посему время работы алгоритма во-первых, не зависит от кл-ва процессов, во-вторых, оно постоянно — O(1).
    
    Completely Fair Scheduler — для хранения процессов использует red-black дерево, где ключём является wait_runtime каждого процесса.
    wait_runtime — это кл-во наносекунд, которое данный процесс недоработал или переработал. 
    т.е. если оно < 0, значит он переработал, если оно > 0, значит он недоработал. 
    эта мера позволяет засечь out-of-ballance от 'идеального случая'. 
    в зависимости от значения wait_runtime, процесс занимает своё место в дереве. если wait_runtime < 0, то процесс будет сидеть на нижних уровнях, если больше 0, то ближе к вершине. 
    следовательно, CFS — не O(1) scheduler, он O(logN). Есть эвристическое замечание, что для поиска подходящего процесса процедуре поиска не потребуется много итераций, 
    так что на практике переключение контекста может занять О(1), но теоретически худший случай, конечно -- логарифм.
